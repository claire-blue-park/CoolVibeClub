---
description: 
globs: 
alwaysApply: false
---
# iOS SwiftUI TCA 개발 규칙

## 프로젝트 구조 및 파일 명명 규칙


## 주석 작성 패턴
- 내용구분 시, `// MARK: - ` 형태를 사용합니다.
- 개발자에게 설명하는 내용 작성 시 `///` 형태를 사용합니다.


### 폴더 구조
- **App**: 앱의 메인 진입점과 전역 설정
- **Features**: 도메인별 기능 모듈 (각 기능은 독립적인 폴더로 구성)
- **Sources**: 공통 소스 코드
  - **App**: ChafzipApp, ContentView 등 앱 레벨 컴포넌트
  - **Services**: 네트워크, 데이터베이스 등 서비스 레이어
  - **Network**: API 통신 관련 코드
  - **Utilities**: 유틸리티 함수 및 확장
  - **Extensions**: Swift/SwiftUI 확장
  - **Helpers**: 도우미 클래스 및 함수

### 파일 명명 규칙
- **Feature 파일**: `{FeatureName}Feature.swift`
- **View 파일**: `{ViewName}View.swift`
- **Model 파일**: `{ModelName}.swift`
- **Service 파일**: `{ServiceName}Service.swift`
- **Extension 파일**: `{Type}+{Extension}.swift`
- 모든 파일명은 PascalCase를 사용합니다.

## TCA Feature 작성 패턴

### 기본 Feature 템플릿
```swift
import ComposableArchitecture
import SwiftUI

// MARK: - State
/// {FeatureName}의 상태를 정의하는 구조체
@Reducer
struct {FeatureName}Feature {
    /// {FeatureName} 화면의 상태
    @ObservableState
    struct State: Equatable {
        /// 로딩 상태
        var isLoading: Bool = false
        /// 에러 메시지
        var errorMessage: String?
        /// 데이터 목록
        var items: [Item] = []
        
        /// 초기 상태 생성자
        init() {}
    }
    
    // MARK: - Action
    /// {FeatureName}에서 발생할 수 있는 모든 액션
    enum Action: Equatable {
        /// 화면이 나타날 때 실행
        case onAppear
        /// 데이터 로드 요청
        case loadData
        /// 데이터 로드 완료
        case loadDataResponse(Result<[Item], Error>)
        /// 아이템 선택
        case itemTapped(Item)
        /// 에러 알림 해제
        case dismissError
        
        /// 내부적으로만 사용되는 액션들
        enum Internal: Equatable {
            case setLoading(Bool)
        }
        case `internal`(Internal)
    }
    
    // MARK: - Dependencies
    /// Feature에서 사용하는 의존성들
    @Dependency(\.apiClient) var apiClient
    @Dependency(\.mainQueue) var mainQueue
    
    // MARK: - Reducer
    /// 상태 변화를 처리하는 리듀서
    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                return .send(.loadData)
                
            case .loadData:
                state.isLoading = true
                state.errorMessage = nil
                
                return .run { send in
                    do {
                        let items = try await apiClient.fetchItems()
                        await send(.loadDataResponse(.success(items)))
                    } catch {
                        await send(.loadDataResponse(.failure(error)))
                    }
                }
                
            case let .loadDataResponse(.success(items)):
                state.isLoading = false
                state.items = items
                return .none
                
            case let .loadDataResponse(.failure(error)):
                state.isLoading = false
                state.errorMessage = error.localizedDescription
                return .none
                
            case let .itemTapped(item):
                // 아이템 선택 처리 로직
                return .none
                
            case .dismissError:
                state.errorMessage = nil
                return .none
                
            case let .internal(internalAction):
                switch internalAction {
                case let .setLoading(isLoading):
                    state.isLoading = isLoading
                    return .none
                }
            }
        }
    }
}

// MARK: - View
/// {FeatureName} 화면을 담당하는 SwiftUI View
struct {FeatureName}View: View {
    /// Feature Store
    let store: StoreOf<{FeatureName}Feature>
    
    var body: some View {
        WithViewStore(store, observe: { $0 }) { viewStore in
            NavigationView {
                ZStack {
                    if viewStore.isLoading {
                        ProgressView("로딩 중...")
                    } else {
                        contentView(viewStore: viewStore)
                    }
                }
                .navigationTitle("{화면 제목}")
                .onAppear {
                    viewStore.send(.onAppear)
                }
                .alert(
                    "오류",
                    isPresented: viewStore.binding(
                        get: { $0.errorMessage != nil },
                        send: .dismissError
                    )
                ) {
                    Button("확인") {
                        viewStore.send(.dismissError)
                    }
                } message: {
                    if let errorMessage = viewStore.errorMessage {
                        Text(errorMessage)
                    }
                }
            }
        }
    }
    
    /// 메인 컨텐츠 뷰
    @ViewBuilder
    private func contentView(viewStore: ViewStoreOf<{FeatureName}Feature>) -> some View {
        List(viewStore.items, id: \.id) { item in
            Button(action: {
                viewStore.send(.itemTapped(item))
            }) {
                Text(item.title)
            }
        }
    }
}

// MARK: - Preview
#Preview {
    {FeatureName}View(
        store: Store(initialState: {FeatureName}Feature.State()) {
            {FeatureName}Feature()
        }
    )
}
```

## SwiftUI View 작성 패턴

### 일반 View 컴포넌트 템플릿
```swift
import SwiftUI

/// {ViewName}에 대한 설명
struct {ViewName}View: View {
    // MARK: - Properties
    /// 필수 프로퍼티에 대한 설명
    let title: String
    /// 선택적 프로퍼티에 대한 설명
    let subtitle: String?
    /// 액션 클로저에 대한 설명
    let onTap: (() -> Void)?
    
    // MARK: - Initializer
    /// {ViewName}View 초기화
    /// - Parameters:
    ///   - title: 제목
    ///   - subtitle: 부제목 (선택사항)
    ///   - onTap: 탭 액션 (선택사항)
    init(
        title: String,
        subtitle: String? = nil,
        onTap: (() -> Void)? = nil
    ) {
        self.title = title
        self.subtitle = subtitle
        self.onTap = onTap
    }
    
    // MARK: - Body
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.headline)
                .foregroundColor(.primary)
            
            if let subtitle = subtitle {
                Text(subtitle)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
        .onTapGesture {
            onTap?()
        }
    }
}

// MARK: - Preview
#Preview {
    VStack(spacing: 16) {
        {ViewName}View(
            title: "샘플 제목",
            subtitle: "샘플 부제목"
        ) {
            print("탭됨")
        }
        
        {ViewName}View(
            title: "제목만 있는 버전"
        )
    }
    .padding()
}
```

## 모델 및 데이터 구조

### 모델 정의 패턴
```swift
import Foundation

/// {ModelName}에 대한 설명
struct {ModelName}: Equatable, Identifiable, Codable {
    /// 고유 식별자
    let id: UUID
    /// 제목
    let title: String
    /// 설명
    let description: String?
    /// 생성 날짜
    let createdAt: Date
    /// 업데이트 날짜
    var updatedAt: Date
    
    /// 기본 초기화
    /// - Parameters:
    ///   - id: 고유 식별자 (기본값: 새 UUID)
    ///   - title: 제목
    ///   - description: 설명 (선택사항)
    ///   - createdAt: 생성 날짜 (기본값: 현재 시간)
    ///   - updatedAt: 업데이트 날짜 (기본값: 현재 시간)
    init(
        id: UUID = UUID(),
        title: String,
        description: String? = nil,
        createdAt: Date = Date(),
        updatedAt: Date = Date()
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

// MARK: - Extensions
extension {ModelName} {
    /// 샘플 데이터
    static let sample = {ModelName}(
        title: "샘플 제목",
        description: "샘플 설명"
    )
    
    /// 여러 샘플 데이터
    static let samples: [{ModelName}] = [
        {ModelName}(title: "첫 번째", description: "첫 번째 설명"),
        {ModelName}(title: "두 번째", description: "두 번째 설명"),
        {ModelName}(title: "세 번째")
    ]
}
```

## 서비스 레이어 패턴

### API 클라이언트 템플릿
```swift
import ComposableArchitecture
import Foundation

/// {ServiceName} API 통신을 담당하는 클라이언트
struct {ServiceName}APIClient {
    /// 데이터 목록을 가져오는 함수
    var fetchItems: @Sendable () async throws -> [Item]
    /// 특정 아이템을 가져오는 함수
    var fetchItem: @Sendable (UUID) async throws -> Item
    /// 새 아이템을 생성하는 함수
    var createItem: @Sendable (CreateItemRequest) async throws -> Item
    /// 아이템을 업데이트하는 함수
    var updateItem: @Sendable (UUID, UpdateItemRequest) async throws -> Item
    /// 아이템을 삭제하는 함수
    var deleteItem: @Sendable (UUID) async throws -> Void
}

// MARK: - Dependency
extension {ServiceName}APIClient: DependencyKey {
    /// 라이브 의존성 (실제 API 호출)
    static let liveValue = Self(
        fetchItems: {
            // 실제 API 호출 구현
            let url = URL(string: "https://api.example.com/items")!
            let (data, _) = try await URLSession.shared.data(from: url)
            return try JSONDecoder().decode([Item].self, from: data)
        },
        fetchItem: { id in
            // 실제 API 호출 구현
            let url = URL(string: "https://api.example.com/items/\(id)")!
            let (data, _) = try await URLSession.shared.data(from: url)
            return try JSONDecoder().decode(Item.self, from: data)
        },
        createItem: { request in
            // POST 요청 구현
            let url = URL(string: "https://api.example.com/items")!
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "POST"
            urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
            urlRequest.httpBody = try JSONEncoder().encode(request)
            
            let (data, _) = try await URLSession.shared.data(for: urlRequest)
            return try JSONDecoder().decode(Item.self, from: data)
        },
        updateItem: { id, request in
            // PUT 요청 구현
            let url = URL(string: "https://api.example.com/items/\(id)")!
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "PUT"
            urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
            urlRequest.httpBody = try JSONEncoder().encode(request)
            
            let (data, _) = try await URLSession.shared.data(for: urlRequest)
            return try JSONDecoder().decode(Item.self, from: data)
        },
        deleteItem: { id in
            // DELETE 요청 구현
            let url = URL(string: "https://api.example.com/items/\(id)")!
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "DELETE"
            
            _ = try await URLSession.shared.data(for: urlRequest)
        }
    )
    
    /// 테스트용 의존성 (Mock 데이터)
    static let testValue = Self(
        fetchItems: { Item.samples },
        fetchItem: { _ in Item.sample },
        createItem: { _ in Item.sample },
        updateItem: { _, _ in Item.sample },
        deleteItem: { _ in }
    )
}

extension DependencyValues {
    /// {ServiceName}APIClient 의존성 접근자
    var {serviceName}APIClient: {ServiceName}APIClient {
        get { self[{ServiceName}APIClient.self] }
        set { self[{ServiceName}APIClient.self] = newValue }
    }
}
```

## 확장(Extensions) 작성 패턴

### View 확장 예시
```swift
import SwiftUI

// MARK: - View Extensions
extension View {
    /// 조건부 modifier 적용
    /// - Parameters:
    ///   - condition: 조건
    ///   - modifier: 적용할 modifier
    /// - Returns: 조건에 따라 modifier가 적용된 View
    @ViewBuilder
    func `if`<Content: View>(_ condition: Bool, modifier: (Self) -> Content) -> some View {
        if condition {
            modifier(self)
        } else {
            self
        }
    }
    
    /// 로딩 오버레이 추가
    /// - Parameter isLoading: 로딩 상태
    /// - Returns: 로딩 오버레이가 적용된 View
    func loadingOverlay(_ isLoading: Bool) -> some View {
        self.overlay(
            Group {
                if isLoading {
                    ZStack {
                        Color.black.opacity(0.3)
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(1.2)
                    }
                }
            }
        )
    }
    
    /// 커스텀 네비게이션 바 스타일 적용
    /// - Parameters:
    ///   - title: 제목
    ///   - backgroundColor: 배경색
    ///   - foregroundColor: 전경색
    /// - Returns: 스타일이 적용된 View
    func customNavigationBar(
        title: String,
        backgroundColor: Color = .blue,
        foregroundColor: Color = .white
    ) -> some View {
        self
            .navigationTitle(title)
            .navigationBarTitleDisplayMode(.large)
            .toolbarBackground(backgroundColor, for: .navigationBar)
            .toolbarBackground(.visible, for: .navigationBar)
            .toolbarColorScheme(.dark, for: .navigationBar)
    }
}
```

## 에러 처리 패턴

### 커스텀 에러 정의
```swift
import Foundation

/// 앱에서 발생하는 에러들을 정의하는 열거형
enum AppError: Error, Equatable, LocalizedError {
    /// 네트워크 연결 오류
    case networkError
    /// 데이터 파싱 오류
    case decodingError
    /// 인증 오류
    case authenticationError
    /// 권한 오류
    case authorizationError
    /// 서버 오류
    case serverError(Int)
    /// 알 수 없는 오류
    case unknown(String)
    
    /// 사용자에게 표시될 에러 메시지
    var errorDescription: String? {
        switch self {
        case .networkError:
            return "네트워크 연결을 확인해주세요."
        case .decodingError:
            return "데이터 처리 중 오류가 발생했습니다."
        case .authenticationError:
            return "로그인이 필요합니다."
        case .authorizationError:
            return "접근 권한이 없습니다."
        case .serverError(let code):
            return "서버 오류가 발생했습니다. (코드: \(code))"
        case .unknown(let message):
            return message
        }
    }
    
    /// 에러 복구 제안
    var recoverySuggestion: String? {
        switch self {
        case .networkError:
            return "인터넷 연결을 확인하고 다시 시도해주세요."
        case .authenticationError:
            return "다시 로그인해주세요."
        case .authorizationError:
            return "관리자에게 문의하세요."
        default:
            return "잠시 후 다시 시도해주세요."
        }
    }
}
```

## 테스트 작성 패턴

### Feature 테스트 템플릿
```swift
import ComposableArchitecture
import XCTest

@testable import YourApp

/// {FeatureName}Feature 테스트
@MainActor
final class {FeatureName}FeatureTests: XCTestCase {
    
    /// 기본 상태 테스트
    func test_initialState() {
        let state = {FeatureName}Feature.State()
        
        XCTAssertFalse(state.isLoading)
        XCTAssertNil(state.errorMessage)
        XCTAssertTrue(state.items.isEmpty)
    }
    
    /// 데이터 로드 성공 테스트
    func test_loadData_success() async {
        let mockItems = [Item.sample]
        
        let store = TestStore(initialState: {FeatureName}Feature.State()) {
            {FeatureName}Feature()
        } withDependencies: {
            $0.apiClient.fetchItems = { mockItems }
        }
        
        await store.send(.loadData) {
            $0.isLoading = true
            $0.errorMessage = nil
        }
        
        await store.receive(.loadDataResponse(.success(mockItems))) {
            $0.isLoading = false
            $0.items = mockItems
        }
    }
    
    /// 데이터 로드 실패 테스트
    func test_loadData_failure() async {
        let error = AppError.networkError
        
        let store = TestStore(initialState: {FeatureName}Feature.State()) {
            {FeatureName}Feature()
        } withDependencies: {
            $0.apiClient.fetchItems = { throw error }
        }
        
        await store.send(.loadData) {
            $0.isLoading = true
            $0.errorMessage = nil
        }
        
        await store.receive(.loadDataResponse(.failure(error))) {
            $0.isLoading = false
            $0.errorMessage = error.localizedDescription
        }
    }
    
    /// 에러 해제 테스트
    func test_dismissError() async {
        let store = TestStore(
            initialState: {FeatureName}Feature.State(
                errorMessage: "테스트 에러"
            )
        ) {
            {FeatureName}Feature()
        }
        
        await store.send(.dismissError) {
            $0.errorMessage = nil
        }
    }
}
```

## 접근성 및 현지화

### 접근성 지원
```swift
// MARK: - Accessibility
extension View {
    /// 접근성 식별자 설정
    /// - Parameter identifier: 식별자
    /// - Returns: 접근성 식별자가 설정된 View
    func accessibilityIdentifier(_ identifier: String) -> some View {
        self.accessibilityIdentifier(identifier)
    }
    
    /// 접근성 레이블과 힌트 설정
    /// - Parameters:
    ///   - label: 접근성 레이블
    ///   - hint: 접근성 힌트
    /// - Returns: 접근성 정보가 설정된 View
    func accessibilityInfo(label: String, hint: String? = nil) -> some View {
        self
            .accessibilityLabel(label)
            .if(hint != nil) { view in
                view.accessibilityHint(hint!)
            }
    }
}
```

### 현지화 지원
```swift
import SwiftUI

/// 현지화된 문자열을 위한 확장
extension String {
    /// 현지화된 문자열 반환
    var localized: String {
        NSLocalizedString(self, comment: "")
    }
    
    /// 매개변수가 있는 현지화된 문자열 반환
    /// - Parameter arguments: 매개변수들
    /// - Returns: 현지화된 문자열
    func localized(with arguments: CVarArg...) -> String {
        String(format: self.localized, arguments: arguments)
    }
}

/// 현지화 키 열거형
enum LocalizationKey: String, CaseIterable {
    case loading = "loading"
    case error = "error"
    case retry = "retry"
    case cancel = "cancel"
    case save = "save"
    case delete = "delete"
    
    /// 현지화된 문자열
    var localized: String {
        self.rawValue.localized
    }
}
```

## 성능 최적화 지침

### 메모리 관리
- 강한 참조 순환을 방지하기 위해 `[weak self]` 사용
- 대용량 이미지나 데이터는 지연 로딩 구현
- 불필요한 State 업데이트 최소화

### 렌더링 최적화
- 복잡한 View는 `@ViewBuilder`로 분리
- 조건부 렌더링 시 `Group`과 `if` 활용
- List 성능을 위해 `id`를 명시적으로 지정

### TCA 최적화
- Effect의 불필요한 실행 방지
- State의 Equatable 구현으로 불필요한 렌더링 방지
- 복잡한 State는 여러 개의 작은 State로 분리

## 코드 스타일 및 컨벤션

### 들여쓰기 및 포맷팅
- 들여쓰기는 4칸 스페이스 사용
- 함수 매개변수가 많을 경우 각 줄에 하나씩 배치
- 닫는 괄호는 함수명과 같은 레벨에 배치

### 주석 작성
- 모든 public 함수와 타입에 대해 문서화 주석 작성
- `/// ` 형식의 문서화 주석 사용
- 복잡한 로직에는 인라인 주석 추가

### 네이밍 컨벤션
- 타입명: PascalCase
- 변수/함수명: camelCase  
- 상수명: camelCase (전역 상수는 대문자 스네이크 케이스)
- 파일명: PascalCase
- 폴더명: PascalCase

이 규칙들을 따라 일관성 있고 유지보수하기 쉬운 iOS SwiftUI TCA 코드를 작성하세요.